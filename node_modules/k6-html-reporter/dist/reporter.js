"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const ejs_1 = __importDefault(require("ejs"));
function generate(options) {
    const resolvedInputPath = path_1.default.resolve(process.cwd(), options.jsonFile);
    const resolvedOutputPath = path_1.default.resolve(process.cwd(), options.output);
    const jsonReport = readJsonReport(resolvedInputPath);
    writeHtmlReport(jsonReport, resolvedOutputPath);
}
exports.generate = generate;
function readJsonReport(filePath) {
    const resolvedPath = path_1.default.resolve(__dirname, filePath);
    const rawData = fs_1.default.readFileSync(resolvedPath);
    return JSON.parse(rawData.toString());
}
function writeHtmlReport(content, filePath) {
    const templatePath = path_1.default.resolve(__dirname, '../templates/template.ejs');
    const checkRootGroupData = content["root_group"];
    const metricsData = content["metrics"];
    const { checkMetric, countMetrics, timeMetrics, vusMetrics, allThresholds, metricThresholdsPassed, failedThresholdsNum } = mapMetrics(metricsData);
    const checks = getChecks(checkRootGroupData).map((data) => {
        const splitedPath = data.path.split('::');
        splitedPath.shift();
        return {
            ...data,
            pathArray: splitedPath.join(" \u21C0 ")
        };
    });
    ejs_1.default.renderFile(templatePath, { checks, checkMetric, countMetrics, timeMetrics, vusMetrics, allThresholds, metricThresholdsPassed, failedThresholdsNum }, {}, function (err, str) {
        if (err) {
            console.error(err);
        }
        let html = ejs_1.default.render(str);
        fs_1.default.writeFileSync(`${filePath}/report.html`, html);
        console.log(`Report is created at ${filePath}`);
    });
}
function mapMetrics(data) {
    let checkMetric = {};
    const countMetrics = [];
    const timeMetrics = [];
    const vusMetrics = [];
    const allThresholds = [];
    let metricThresholdsPassed = true;
    let failedThresholdsNum = 0;
    Object.entries(data).forEach(([key, value]) => {
        if (Object.keys(value).includes('count')) {
            const thresholdFailed = thresholdResult(value.thresholds);
            if (thresholdFailed === true) {
                failedThresholdsNum++;
                metricThresholdsPassed = false;
            }
            countMetrics.push({
                name: key,
                ...value,
                thresholdFailed
            });
            if (Object.keys(value).includes('thresholds')) {
                allThresholds.push({
                    name: key,
                    thresholds: value.thresholds
                });
            }
        }
        else if (Object.keys(value).includes('avg')) {
            const thresholdFailed = thresholdResult(value.thresholds);
            if (thresholdFailed === true) {
                failedThresholdsNum++;
                metricThresholdsPassed = false;
            }
            timeMetrics.push({
                name: key,
                ...value,
                thresholdFailed
            });
            if (Object.keys(value).includes('thresholds')) {
                allThresholds.push({
                    name: key,
                    thresholds: value.thresholds
                });
            }
        }
        else if (Object.keys(value).includes('passes')) {
            const thresholdFailed = thresholdResult(value.thresholds);
            if (thresholdFailed === true) {
                failedThresholdsNum++;
            }
            checkMetric = {
                name: key,
                ...value,
                thresholdFailed
            };
            if (Object.keys(value).includes('thresholds')) {
                allThresholds.push({
                    name: key,
                    thresholds: value.thresholds
                });
            }
        }
        else if (key.includes('vus')) {
            const thresholdFailed = thresholdResult(value.thresholds);
            if (thresholdFailed === true) {
                failedThresholdsNum++;
                metricThresholdsPassed = false;
            }
            vusMetrics.push({
                name: key,
                ...value,
                thresholdFailed
            });
            if (Object.keys(value).includes('thresholds')) {
                allThresholds.push({
                    name: key,
                    thresholds: value.thresholds
                });
            }
        }
    });
    return { checkMetric, countMetrics, timeMetrics, vusMetrics, allThresholds, metricThresholdsPassed, failedThresholdsNum };
}
function thresholdResult(thresholds) {
    if (thresholds) {
        return Object.values(thresholds).some(value => value === true);
    }
}
function getChecks(data) {
    const checksOutput = [];
    findChecksRecursively(data);
    function findChecksRecursively(data) {
        if (data.groups.length === 0) {
            return;
        }
        if (Object.keys(data.checks).length > 0) {
            Object.values(data.checks).forEach((value) => {
                checksOutput.push(value);
            });
        }
        for (let item in data.groups) {
            findChecksRecursively(data.groups[item]);
        }
    }
    return checksOutput;
}
//# sourceMappingURL=reporter.js.map